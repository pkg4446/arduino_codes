/*
 * Project: C6_testcode (V3.41 Hardware Full Option - Fast Serial)
 * Version: 1.4.3_Compile_Fix
 * Target: ESP32-C6-MINI-1U
 *
 * [Fix] config_update_check() 함수 내 Serial_command() 호출 순서 오류 수정
 */

#include <Update.h>
#include <EEPROM.h>
#include <Wire.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <Adafruit_SHT31.h>
#include <Adafruit_MAX1704X.h>
#include <OneWireNg_CurrentPlatform.h>
#include <esp_task_wdt.h>
#include "uart_print.h"

String firmwareVersion = "1.4.3_Fix";

// [시스템 설정]
#define uS_TO_S_FACTOR      1000000
#define SECONDE             1000L
#define COMMAND_LENGTH      64  
#define WDT_TIMEOUT         30  
#define EEPROM_SIZE         128

// [핀 설정 - V3.41]
#define PIN_SDA         6   
#define PIN_SCL         7   
#define PIN_AC_DETECT   3   
#define PIN_LED_STATUS  22  
#define PIN_SSR_HEATER  23  
#define PIN_DS_EXT      4   
#define PIN_DS_SPACE    5   
#define PIN_CONFIG      2   

// [객체]
RTC_DATA_ATTR uint32_t bootCount = 0;
Adafruit_SHT4x sht = Adafruit_SHT4x(); 
Adafruit_MAX17048 maxlipo;
OneWireNg *owExt = NULL;
OneWireNg *owSpace = NULL;

// [변수]
const String server = "http://test.beetopia.kro.kr/device/log";
char deviceID[18];

char command_buf[COMMAND_LENGTH];
int8_t command_num = 0;

// EEPROM Map
const int ADDR_SSID = 0;   
const int ADDR_PASS = 32;  
const int ADDR_HEAT = 64; 
const int ADDR_GAP  = 65; 
const int ADDR_GOAL = 66; 
const int ADDR_FLAG = 100; 
const int MAGIC_NUM = 0xC3; 

char wifi_ssid[32] = "";
char wifi_pass[32] = "";

bool heat_mode = false;
int  upload_gap = 5;
int  temp_goal = 30;

// 센서 값
float t_ext = 0.0, t_spc = 0.0;
float t_sht = 0.0, h_sht = 0.0;
float bat_pct = 0.0, bat_vol = 0.0;

bool wifi_connected = false;
bool heater_state = false;
bool ac_connected = false;

unsigned long last_upload = 0;

// [함수 프로토타입 선언 - 중요!]
void load_settings();
void save_settings();
void factory_reset();
bool wifi_connect();
void WIFI_scan();
void httpPOSTRequest(String serverUrl);
String send_data();
void serial_command_help();
void serial_wifi_config(String ssid, String pass);
void command_process(char ch);
void Serial_command(); // 선언 추가
String String_slice(uint8_t *check_index, String text, char check_char);
void config_update_check();
void read_sensors();
float readDS18B20(OneWireNg *ow);
void control_heater();
void update_led();
void scan_i2c();

void setup(){
  Serial.begin(115200);
  
  // WDT
  esp_task_wdt_deinit(); 
  esp_task_wdt_config_t wdt = {
      .timeout_ms = WDT_TIMEOUT * 1000,
      .idle_core_mask = (1 << 0),
      .trigger_panic = true
  };
  esp_task_wdt_init(&wdt);
  esp_task_wdt_add(NULL);
  
  delay(1000); 

  WiFi.mode(WIFI_STA);
  delay(100);

  // Pins
  pinMode(PIN_LED_STATUS, OUTPUT);
  pinMode(PIN_SSR_HEATER, OUTPUT);
  pinMode(PIN_AC_DETECT, INPUT);
  pinMode(PIN_CONFIG, INPUT_PULLUP);
  digitalWrite(PIN_SSR_HEATER, LOW); 

  // 1-Wire
  owExt = new OneWireNg_CurrentPlatform(PIN_DS_EXT, false);
  owSpace = new OneWireNg_CurrentPlatform(PIN_DS_SPACE, false);

  // I2C
  Wire.begin(PIN_SDA, PIN_SCL);
  
  if (!sht.begin()) Serial.println("[ERR] SHT40 Fail");
  else {
      sht.setPrecision(SHT4X_HIGH_PRECISION);
      sht.setHeater(SHT4X_NO_HEATER);
  }

  if (!maxlipo.begin()) Serial.println("[ERR] MAX17048 Fail");

  // EEPROM
  if (!EEPROM.begin(EEPROM_SIZE)) {
      Serial.println("[ERR] EEPROM Fail");
      ESP.restart();
  }

  if (EEPROM.read(ADDR_FLAG) != MAGIC_NUM) {
      Serial.println("[BOOT] Factory Resetting...");
      factory_reset();
  } else {
      load_settings();
  }

  // ID
  String mac = WiFi.macAddress();
  if (mac == "00:00:00:00:00:00") { delay(100); mac = WiFi.macAddress(); }
  for (uint8_t i = 0; i < 17; i++) {
      deviceID[i] = (mac[i]==':') ? '_' : mac[i];
  }
  deviceID[17] = 0; 

  ++bootCount;
  Serial.printf("\n[BOOT] ID: %s (Ver: %s)\n", deviceID, firmwareVersion.c_str());
  serial_command_help();

  // 초기 WiFi 연결
  wifi_connect();
}

void loop(){
    esp_task_wdt_reset();
    
    // [최우선] 시리얼 입력 처리
    while(Serial.available()) {
        command_process(Serial.read());
    }

    config_update_check(); 

    static unsigned long last_sec = 0;
    if (millis() - last_sec > 1000) {
        last_sec = millis();
        read_sensors();
        control_heater();
        update_led();

        if (wifi_connected && (millis() - last_upload > (unsigned long)upload_gap * 60 * 1000)) {
             httpPOSTRequest(server);
             last_upload = millis();
        }
    }
    
    delay(1); 
}

// ==========================================
//           SERIAL & COMMAND
// ==========================================

void command_process(char ch) {
  if (ch == '\n') { 
    command_buf[command_num] = 0; 
    
    if (command_num == 0) {
        serial_command_help();
    } else {
        uint8_t idx = 0;
        String raw = String(command_buf);
        String cmd = String_slice(&idx, raw, 0x20); 
        String arg = String_slice(&idx, raw, 0x20);

        if(cmd == "reboot") {
            Serial.println("System reboot...");
            delay(100);
            ESP.restart();
        }
        else if(cmd == "temp") {
            read_sensors();
            Serial.println("\n--- Sensor Status ---");
            Serial.printf("Ext  : %.1f C\n", t_ext);
            Serial.printf("Space: %.1f C\n", t_spc);
            Serial.printf("SHT  : %.1f C / %.1f %%\n", t_sht, h_sht);
            Serial.printf("Bat  : %.1f %% (%.2f V)\n", bat_pct, bat_vol);
            Serial.printf("AC   : %s\n", ac_connected ? "ON" : "OFF");
            Serial.println("---------------------");
        }
        else if(cmd == "config") {
            Serial.println("\n--- Settings ---");
            Serial.printf(" SSID: %s\n", (strlen(wifi_ssid) > 0) ? wifi_ssid : "(Empty)");
            Serial.printf(" Heat: %s\n", heat_mode ? "ON" : "OFF");
            Serial.printf(" Goal: %d C\n", temp_goal);
            Serial.printf(" Gap : %d min\n", upload_gap);
            Serial.println("----------------");
        }
        else if(cmd == "ssid") {
            arg.toCharArray(wifi_ssid, 32);
            save_settings();
            serial_wifi_config(wifi_ssid, wifi_pass);
        }
        else if(cmd == "pass") {
            arg.toCharArray(wifi_pass, 32);
            save_settings();
            serial_wifi_config(wifi_ssid, wifi_pass);
        }
        else if(cmd == "wifi") {
            if(arg == "scan") WIFI_scan();
            else if(arg == "stop") { WiFi.disconnect(true); wifi_connected = false; Serial.println("WiFi Disconnected"); }
            else wifi_connect();
        }
        else if(cmd == "run") {
            heat_mode = (arg == "on");
            save_settings();
            Serial.printf("Heat Mode: %s\n", heat_mode ? "ON" : "OFF");
        }
        else if(cmd == "set") {
            int val = arg.toInt();
            if(val > 0) { temp_goal = val; save_settings(); Serial.printf("Goal Temp Set: %d\n", temp_goal); }
        }
        else if(cmd == "gap") {
            int val = arg.toInt();
            if(val > 0) { upload_gap = val; save_settings(); Serial.printf("Upload Gap Set: %d min\n", upload_gap); }
        }
        else if(cmd == "test") {
            if(arg == "data") httpPOSTRequest(server);
        }
        else if(cmd == "i2c") {
            scan_i2c();
        }
        else if(cmd == "reset") {
            factory_reset();
            Serial.println("Factory Reset Done. Rebooting...");
            delay(1000);
            ESP.restart();
        }
        else {
            Serial.println("Unknown command.");
        }
    }
    
    command_num = 0;
    memset(command_buf, 0, COMMAND_LENGTH);
    
  } else if (ch != '\r') {
    if (command_num < COMMAND_LENGTH - 1) {
        command_buf[command_num++] = ch;
    }
  }
}

// 이 함수가 아래에 정의되어 있어서 위에서 선언 필요
void Serial_command() { if (Serial.available()) command_process(Serial.read()); }

String String_slice(uint8_t *check_index, String text, char check_char){
  String response = "";
  for(uint8_t index_check=*check_index; index_check<text.length(); index_check++){
    if(text[index_check] == check_char || text[index_check] == 0x00){
      *check_index = index_check+1;
      break;
    }
    response += text[index_check];
  }
  return response;
}

// [V2 Style Help Menu]
void serial_command_help() {
  Serial.println("\n************* help *************");
  Serial.println("reboot  * system reboot");
  Serial.println("temp    * temperature show");
  Serial.println("run     * homeothermy mode");
  Serial.println("   on   *");
  Serial.println("   off  *");
  Serial.println("set     * temperature goal setup. ex) set 25");
  Serial.println("config  * read temperature setup");
  Serial.println("gap     * set upload interval");
  Serial.println("test    *");
  Serial.println("   data * data to server");
  Serial.println("ssid    * ex)ssid your ssid");
  Serial.println("pass    * ex)pass your password");
  Serial.println("wifi    * WIFI connet");
  Serial.println("   scan * WIFI scan");
  Serial.println("   stop * WIFI disconnet");
  Serial.println("i2c     * scan i2c devices");
  Serial.println("reset   * factory reset");
  Serial.println("********************************");
}

void serial_wifi_config(String ssid, String pass){
  Serial.println("********* wifi config *********");
  Serial.print("your ssid: "); Serial.println(ssid);
  Serial.print("your pass: "); Serial.println(pass);
  Serial.println("********* wifi config *********");
}

// ==========================================
//              SENSORS
// ==========================================
void read_sensors() {
    t_ext = readDS18B20(owExt);
    t_spc = readDS18B20(owSpace);

    sensors_event_t humidity, temp;
    if (sht.getEvent(&humidity, &temp)) { 
        t_sht = temp.temperature;
        h_sht = humidity.relative_humidity;
    }

    bat_vol = maxlipo.cellVoltage();
    bat_pct = maxlipo.cellPercent();
    if (isnan(bat_pct)) bat_pct = 0.0;
}

float readDS18B20(OneWireNg *ow) {
    if (!ow) return 0.0;
    ow->reset(); ow->writeByte(0xCC); ow->writeByte(0x44);
    unsigned long start = millis();
    while(millis() - start < 750) { 
        esp_task_wdt_reset(); 
        if(Serial.available()) command_process(Serial.read()); 
        delay(1); 
    }
    
    ow->reset(); ow->writeByte(0xCC); ow->writeByte(0xBE);
    uint8_t data[9];
    for (int i = 0; i < 9; i++) data[i] = ow->readByte();
    int16_t raw = (data[1] << 8) | data[0];
    float temp = (float)raw / 16.0;
    return (temp > -55.0 && temp < 125.0) ? temp : 0.0;
}

// ==========================================
//              CONTROL & LOGIC
// ==========================================
void control_heater() {
    ac_connected = (digitalRead(PIN_AC_DETECT) == LOW);
    if (ac_connected && heat_mode && t_ext != 0.0) {
        if (t_ext < temp_goal - 2) heater_state = true;
        else if (t_ext >= temp_goal) heater_state = false;
    } else {
        heater_state = false; 
    }
    digitalWrite(PIN_SSR_HEATER, heater_state);
}

void update_led() {
    if (heater_state) digitalWrite(PIN_LED_STATUS, (millis() / 500) % 2);
    else if (wifi_connected) digitalWrite(PIN_LED_STATUS, HIGH);
    else digitalWrite(PIN_LED_STATUS, LOW);
}

// ==========================================
//              WIFI & NETWORK
// ==========================================
void WIFI_scan() {
    WiFi.disconnect(true); delay(100);
    Serial.println("WIFI Scanning...");
    int n = WiFi.scanNetworks();
    if (n == 0) {
        Serial.println("WIFI not found!");
    } else {
        Serial.print(n);
        Serial.println(" networks found");
        Serial.println("Nr | SSID                             | RSSI | Enc");
        for (int i = 0; i < n; ++i) {
            Serial.printf("%2d | %-32.32s | %4d | ", i + 1, WiFi.SSID(i).c_str(), WiFi.RSSI(i));
            byte wifi_type = WiFi.encryptionType(i);
            if(wifi_type == WIFI_AUTH_OPEN) Serial.println("Open");
            else Serial.println("Secured");
            delay(10);
        }
    }
    WiFi.scanDelete();
    wifi_connect();
}

bool wifi_connect() {
  if (strlen(wifi_ssid) == 0) { Serial.println("ssid not set"); return false; }
  
  serial_wifi_config(wifi_ssid, wifi_pass);
  
  WiFi.disconnect(true);
  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_pass);
  
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    if(millis() - start > 10000){ 
        Serial.println("not connected"); 
        digitalWrite(PIN_LED_STATUS, LOW);
        return false; 
    }
    delay(100); Serial.print(".");
    esp_task_wdt_reset();
    while(Serial.available()) command_process(Serial.read()); 
  }
  Serial.println("");
  Serial.print("wifi on (IP: ");
  Serial.print(WiFi.localIP());
  Serial.println(")");
  digitalWrite(PIN_LED_STATUS, HIGH);
  wifi_connected = true;
  return true;
}

String send_data(){
  read_sensors();
  
  String httpRequestData = (String)"{\"DVC\":\""+String(deviceID)+"\",\"data\":{";
  httpRequestData += "\"count\":"+String(bootCount)+"";
  httpRequestData += ",\"sht40\":[\""; 
  if(t_ext != 0.0 || t_sht != 0.0) httpRequestData += String(t_ext)+"\",\""+String(t_spc)+"\",\""+String(t_sht)+"\",\""+String(h_sht);
  else httpRequestData += "NaN\",\"NaN\",\"NaN\",\"NaN";
  httpRequestData += "\"],";
  httpRequestData += "\"bat\":[\"";
  httpRequestData += String(bat_pct)+"\",\""+String(bat_vol);
  httpRequestData += "\"]}}";
  return httpRequestData;
}

void httpPOSTRequest(String serverUrl) {
  if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi Disconnected");
      wifi_connected = false;
      return;
  }
  WiFiClient client;
  HTTPClient http;
  http.begin(client, serverUrl);
  http.addHeader("Content-Type", "application/json");
  int code = http.POST(send_data());
  
  Serial.println(serverUrl);
  Serial.println(code);
  
  if (code > 0) Serial.println("Response: " + http.getString());
  else Serial.printf("Error: %s\n", http.errorToString(code).c_str());
  
  http.end();            
}

// ==========================================
//              UTILS
// ==========================================
void config_update_check(){
  if(!digitalRead(PIN_CONFIG)){ 
    serial_command_help();
    while (!digitalRead(PIN_CONFIG)) { 
        esp_task_wdt_reset(); 
        Serial_command();
        delay(10); 
    }
  }
}

void load_settings() {
    for(int i=0; i<32; i++) wifi_ssid[i] = char(EEPROM.read(ADDR_SSID + i));
    for(int i=0; i<32; i++) wifi_pass[i] = char(EEPROM.read(ADDR_PASS + i));
    heat_mode = EEPROM.read(ADDR_HEAT);
    upload_gap = EEPROM.read(ADDR_GAP);
    temp_goal = EEPROM.read(ADDR_GOAL);
    if (upload_gap == 0 || upload_gap > 240) upload_gap = 5;
    if (temp_goal == 0 || temp_goal > 50) temp_goal = 30;
}

void save_settings() {
    for(int i=0; i<32; i++) EEPROM.write(ADDR_SSID + i, (i < String(wifi_ssid).length()) ? wifi_ssid[i] : 0);
    for(int i=0; i<32; i++) EEPROM.write(ADDR_PASS + i, (i < String(wifi_pass).length()) ? wifi_pass[i] : 0);
    EEPROM.write(ADDR_HEAT, heat_mode);
    EEPROM.write(ADDR_GAP, upload_gap);
    EEPROM.write(ADDR_GOAL, temp_goal);
    EEPROM.commit();
}

void factory_reset() {
    memset(wifi_ssid, 0, 32);
    memset(wifi_pass, 0, 32);
    heat_mode = false;
    upload_gap = 5;
    temp_goal = 30;
    save_settings();
    EEPROM.write(ADDR_FLAG, MAGIC_NUM);
    EEPROM.commit();
}

void scan_i2c() {
    byte error, address;
    int nDevices = 0;
    Serial.println("I2C Scan...");
    for (address = 1; address < 127; address++) {
        Wire.beginTransmission(address);
        error = Wire.endTransmission();
        if (error == 0) {
            Serial.printf("Found 0x%02X\n", address);
            nDevices++;
        }
    }
    if (nDevices == 0) Serial.println("No I2C devices");
}